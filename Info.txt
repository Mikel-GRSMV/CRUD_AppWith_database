CRUD,REST,Паттерн DAO (Data Access Object)
CRUD приложение. Часть 1.
------------------------------------------------------------------------------------------------------------------------
CRUD - стандартная классификация функций по манипуляции данными.

Четыре базовые функции, используемые при работе с базами данных:
- Create (создаем что то новое)
- Read (читаем)
- Update (обновляем существующие значения)
- Delete (удаляем)
========================================================================================================================
CRUD приложение - это приложение, которое позволяет добавлять, читать, обнолвять, удалять данные.

               C,U,D
CRUD        ----------> База
приложение  <---------- Данных
                 R
========================================================================================================================
Чаще всего CRUD приложения являются Web-приложениями. Те доступ к БД представляется через протокол HTTP.

                HTTP                       CRUD
          Post,Patch,Delete
Клиент через  --------> CRUD приложение  --------> База
браузер       <-------- (на web сервере) <-------- Данных
                 GET
Большинство Web-приложений - CRUD приложения
========================================================================================================================
Пример CRUD'а для сущности Post

HTTP метод      URL           |         Действие
                              |
- GET         /posts          | Получаем все записи(READ)
- POST        /posts          | Создаем новую запись(CREATE)
- GET         /posts/new      | HTML форма создания записи
- GET         /posts/:id/edit | HTML форма редактирования записи
- GET         /posts/:id      | Получаем одну запись(READ)
- PATCH       /posts/:id      | Обновляем запись(UPDATE)
- DELETE      /posts/:id      | Удаляем запись(DELETE)

Почему именно такие URL'ы и HTTP методы?
Дело в том что вот это все описывается стандартом REST
- REST - это паттерн проектирования веб приложений
- REST описывает то, как посредством протокола HTTP должен взаимодействовать клиент с сервером
- Все взаимодействия с сервером сводится к 4 опциям-получение данных,добавление новых данных,изменение существующих данных,
удаление данных.
- Для каждой из 4 операций используется свой HTTP метод-GET,POST,PATCH,DELETE

И это не все правила и ограничения, которые описаны в REST. Есть множество других.
========================================================================================================================
REST vs CRUD
CRUD-четыре базовые функции, используемые при работе с БД
REST-паттерн проектирования web-приложений. Описывает, как по протоколу HTTP взаимодействовать с сервером для чтения,добавления,
изменения,удаления данных.Описывает,какие URL'ы,HTTP методы использовать(но не только это).
------------------------------------------------------------------------------------------------------------------------
Что будем делать?
Реализуем CRUD приложение для сущности Person

                                                   C,U,D
GET/people       |PeopleController | ---> |Person | ---> People
GET/people/:id   |  @Controller    |      |Model  | <---   DB
                                                      R

(1) Реализуем операцию READ
(2) Мы хотим вынести логику взаимодействия с БД из самой модели в отдельный класс. Паттерн проектирования, когда отдельный
класс занимается взаимодействием с БД для конкретной сущности называется DAO.Паттерн DAO(Data Access Object)

Person ---> PersonDAO ---> БД
       <---           <---
-Вся логика работы с БД для модели Person инкапсулируется в класс PersonDAO
-В DAO классах обычно пишется SQL код для работы с БД приложения (чтение,запись,обновление,удаление)
-Есть другой паттерн взаимодействия с БД-репозиторий.Этот паттерн предоставляет большую абстракцию над БД,чем DAO.
========================================================================================================================
========================================================================================================================
Аннотация @ModelAttribute.
HTML формы(Thymeleaf).

Аннотация @ModelAttribute.
может аннотировать:
- метод
@ModelAttribute("headerMessage")
public String populateHeaderMessage(){
return "Welcome to our website!";
}
-аргумент метода
@PostMapping()
public String create(@ModelAttribute("person") Person person){
personDAO.save(person);
return "redirect:/people";
}
========================================================================================================================
========================================================================================================================
Валидация форм.Аннотация @Valid.
Мы добавили email и возраст каждого человека, но у нас есть проблема и заключается она в том, что наши формы никак не
валидируют свои значения. Например мы создаем человека указав пустые поля. Сейчас мы сделаем так чтобы наши поля
волидировались, чтобы мы не могли создать такого человека с пустыми полями!

(1)Сначала добавим зависимость которая позволит с помощью аннотации устанавливать правила волидации в нашей моделе Person
Hibernate Validator Engine

(2)Добавляем наши новые аннотации полученные от Hibernate Validator Engine
- @NotEmpty(message = "Name should not be empty") //здесь может быть и больше аннотаций добавим еще несколько
  @Size(min = 2,max = 30, message = "Name should be between 2 and 30 characters")
  private String name;
- @Min(value = 0, message = "Age should be greater than 0")
  private int age;
- @NotEmpty(message = "Email should not be empty")
  @Email(message = "Email should be valid")
  private String email;
Теперь мы можем использовать эти аннотации чтобы волидировать те данные которые поступают с формы тк наши формы тесно
связаны с нашей моделью класса Person

(3) Добавим аннотацию @Valid в наш класс Person
@PostMapping()
public String create(@ModelAttribute("person") @Valid Person person,
                     BindingResult bindingResult) { //добавили нашу аннотацию и если есть ошибка то эта ошибка помещается
                     //в отдельный объект BindingResult bindingResult и она должна идти после модели
                     //далее проверям есть ли ошибки в данном аргументе?
                     if (bindingResult.hasErrors()){
                                 return "people/new";//и если есть ошибки то мы сразу возвращаем на создание человека
                             }
     personDAO.save(person);
     return "redirect:/people";

        }
и тоже самое делаем с методом update

(4) отредактируем наше представление
- начнем с формы создания нового человека (new) - здесь мы должны добавить такой HTML код, который будет показывать
ошибки волидации том случае если они есть те мы с контроллера с помощью аннотации @ModelAttribute в модель помещаем
@Valid Person person - объект если в нем есть ошибки которые мы получили с помощью аннотации @Valid то мы должны показать
рядом с каждым полем ошибку валидации относящуюсю к каждой из полей, если же ошибок нет то мы ничего не показываем.
И для этого мы используем механизм в Thymeleaf - <div th:if="${fields.hasErrors('name')}" th:errors="*{name}">Error<div>

(5) И сделаем текст красного цвета.Для это возьмем обычный HTML отрибут style="color:red" который есть у тега div.

(6) Сделаем все тоже самое для обновления пользователя
========================================================================================================================
========================================================================================================================
JDBC API. Базы данных
Мы установим базу данных, свяжем эту БД с нашим Spring application с помощью JDBC и перепишем часть CRUD приложения таким
образом чтобы оно работало с БД
========================================================================================================================
Проблема: Зачем вообще использовать БД?
У нас есть CRUD приложение и в этом CRUD приложении в качестве условной БД мы используем arrayList те динамический список
и проблема заключается в том что при перезапуске приложения мы теряем сохраненные данные. Необходимо хранить данные на
жестком диске, а не в оперативной памяти.

Реляционные БД - Хранят данные в виде набора таблиц
будем использовать БД PostgreSQL
- Одна из самых популярных реляционных БД
- Бесплатная и с открытым тсходным кодом
- Более "навороченная" чем MySQL
Но можно использовать и другую БД. Код по большей части будет совпадать(нужен будет лишь другой JDBC драйвер).
========================================================================================================================
Связь Java приложения с БД

person1     |
id: 1       | -------------->                                 id | name
name: Tom   |                      JDBC API                   ---------
                                 JdbcTemplate --------->      1  | Tom
person1     |                     Hibernate                   2  | Bob
id: 2       | -------------->                                 3  | Alice
name: Bob   |                                               (3 rows)
                                                          Таблица Person в БД
person1     |
id: 3       | -------------->
name: Alice |
Java объекты

Но между 3 спосабами есть разница:
- JDBC API-самый низкоуровневый(сами делаем все запросы к БД и сами переводим Java объекты в строки таблицы и наоборот)

- JdbcTemplate-тонкая обертка вокруг JDBC API. Часть Spring Framework. Предоставляет неоторые абстракции, берет часть
дел на себя

- Hibernate-самый высокий уровень абстракции. Практически не пишем вручную запросы к БД. Автоматически переводит
Java объекты в строки таблицы и наоборот. Может автоматически создавать таблицы в БД на основании наших Java классов.
Этот функционал называется ORM(Object Relation Mapping)
========================================================================================================================
Как подключиться к БД?

- Запускаем БД(локально или удаленно)

- У работающей БД есть свой адрес (как и у сервера)
Адрес БД: url=jdbc:postgresql://localhost:5432/db_name username=postgres password=

- Используем JDBC драйвер, чтобы подключиться к БД с указанным адресом

- Можем делать запросы к БД из Java приложения
========================================================================================================================
Базовые SQl команды:

- CREATE DATABASE db_name; - создает базу данных с указаным именем

- DROP DATABASE db_name; - удаляет БД с указанным именем

- CREATE TABLE table_name (
         id int,            - создает таблицу с указанным именем
         name varchar
);

- DROP TABLE table_name; - удаление таблицы с указанным именем

и все эти команды относятся к большой группе DDL(Data Definition Language)
------------------------------------------------------------------------------------------------------------------------
-SELECT id, name FORM table_name; - выбираем строки из сущ-й БД

-SELECT * FORM table_name; - как первая команда только выбирает все строки из нашей таблицы

-INSERT INTO Person(id, name) VALUES (1, 'TOM'); - добавляем строки в нашу таблицу

-UPDATE Person SET name='Tom123' WHERE id=1; - изменяет значение у сущ-й строки

-DELETE FROM Person WHERE id=1; - удаляет строку из таблицы

и все эти команды относятся к большой группе DML(Data Manipulation Language)
========================================================================================================================
(1)теперь мы часть методов перепишем чтобы они работали с настоящей БД. Но перед этим нам надо создать таблицу.
И в IDE мы можем подключиться к БД. ТК мы запустили базу данных через PgAdmin мы можем к ней подключиться через IDE.

(2)скопироали нашу ссылку jdbc:postgresql://localhost:5432/first_db

(3) create table Person( //создали нашу таблицу Person
        id int,          // колонка id целочисленная
        name varchar,    // колонка name строковая
        age int,         // колонка age целочисленная
        email varchar    // колонка email строковая
    )
пока все без проверок

(4) добавим еще одну зависимость
<!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.20</version>
</dependency>
она будет являться JDBC драйвером

(5) Меняем метод index
public List<Person> index() {
        List<Person> people = new ArrayList<>();
        try {
            Statement statement = connection.createStatement();//это тот объект который содержит в себе SQL запрос к БД
            String SQL = "SELECT * FROM Person"; //наш SQL запрос который будет делаться в этом методе
            ResultSet resultSet = statement.executeQuery(SQL);//вернется несколько строчек из нашей БД эти строки помещаются в объект ResultSet
            while (resultSet.next()){
                Person person = new Person();
                person.setId(resultSet.getInt("id"));
                person.setName(resultSet.getString("name"));
                person.setEmail(resultSet.getString("email"));
                person.setAge(resultSet.getInt("age"));
                people.add(person);//и добавляем нашего человека в список people
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        return people;
    }
(6) Меняем метод save
 public void save(Person person) {
        try {
            Statement statement = connection.createStatement();
            String SQL = "INSERT INTO Person VALUES("+ 1 +",'" + person.getName() +
                    "'," + person.getAge() + ",'" + person.getEmail() + "')";
            statement.executeUpdate(SQL); //нужен для изменения данных
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
========================================================================================================================
Теперь поговорим про SQL инъекции и как ее решить при помощи PreparedStatement.

Составление SQL запроса вручную
Statement statement = connection.createStatement();
            String SQL = "INSERT INTO Person VALUES("+ 1 +",'" + person.getName() +
                    "'," + person.getAge() + ",'" + person.getEmail() + "')";
                    statement.executeUpdate(SQL);
1)Неудобно
2)Легко допустить ошибку
3)Угроза SQL инъекции

SQL инъекция-один из самых распространненных способов взлома сайтов и программ, работающих с базами данных.
тк строки из HTML формы напрямую конкатенируются в SQL запросе, злоумышленник может подобрать такую строку,
которая нанесет вред.
Если в качестве email'а в форме мы введем строку:
test@mail.ru'); DROP TABLE Person; --
INSERT INTO Person VALUES(1, 'test', 15, 'test@mail.ru'); DROP TABLE Person; --');
то полностью удалится вся таблица Person.

SQL инъекции бывают разные

UserId: 105 OR 1=1
Then, the SQL statement will look like this(Тогда инструкция SQL будет выглядеть так)
SELECT * FROM User WHERE UserId = 105 OR 1=1;//такой SQL запрос
мы получим все строки для всех пользователей из таблицы. ТК всегда все два пункта будут true

Как зазащититься от SQL инъекции?
В JDBC API есть специальный класс PreparedStatement это то, что должно использоваться для всех запросов, где содержатся
данные, полученные от пользователя. SQL запрос компилируется один раз и не может быть изменен. Данные от пользователя
могут быть вставлены лишь в указанные места запроса и не могут изменить сам SQL запрос.

PreparedStatement преимущества:
- Удобнее использовать, чем Statement (не надо вручную заниматься конкатенацией)
- Предотвращает SQL инъекции
- Быстрее, чем Statement. Особенно если запросов много

PreparedStatement vs Statement:
- PreparedStatement - SQL запрос компилируется только один раз
- Statement - SQL запрос компилируется каждый раз
- PreparedStatement - может еще кэшироваться на самой БД

(1) перепишем метод save чтобы избежать SQL инъекции

(2) теперь реализуем метод show
Этот метод должен принимать аргумент id должен находить человека с этим id и возвращать из БД и показывать на странице
почему указываем переменную типа Person в начале? если мы объявим в try/catch то это переменная не будет видна return'у

(3) реализуем метод Update
этот метод будет обновлять человека, обновлять значение строки в БД

(4) реализуем метод Delete
Он должен удалять человека из таблицы с указаным id
========================================================================================================================
Поговорим о Spring JdbcTemplate
это технология которая находится выше чем JDBC API и эта технология является тонкой оберткой вокруг JDBC API и облегчает
нам взаимодействие с БД.

Проблемы JDBC API:
- Много лишнего кода (создание Connection, Statement, работа с ResultSet)
- дублирование кода index(), show(int id)
- неинформатичный SQLException, который надо везде обрабатывать

(1) Добавим зависмость в наш проект
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>
эта зависимость как раз и предоставляет нам класс JdbcTemplate

(2) теперь нам необходимо создать этот объект в SpringConfig
@Bean //теперь можем внедрять в дургие классы которые работают с БД
    public DataSource dataSource() { //источник данных этот бин как раз нужен для указания на БД для подключения
        DriverManagerDataSource dataSource = new DriverManagerDataSource();

//описываем нашу базу данных
        dataSource.setDriverClassName("org.postgresql.Driver"); //драйвер
        dataSource.setUrl("jdbc:postgresql: //localhost:5432/first_db"); //URL
        dataSource.setUsername("postgres"); //Username
        dataSource.setPassword("postgres"); //password

        return dataSource; //вернули dataSource
        //теперь будет создан бин dataSource
    }
    @Bean //теперь можем внедрять в дургие классы которые работают с БД
    public JdbcTemplate jdbcTemplate() {
        return new JdbcTemplate(dataSource()); //добавили в конструктор наш бин dataSource
    }
}

(3) теперь когда у нас в нашем DAO есть этот объект мы можеи удалить весь код с подключением к БД, тк все данные перешли
в DataSource и Spring за нас создал этот DataSource за нас создал jdbcTemplate. И теперь при помощи этого мы можем делать
запросы к БД.

(4) Переделаем метод index
//удаляем всеь этот код
public List<Person> index() {
        List<Person> people = new ArrayList<>();
           try {
            Statement statement = connection.createStatement();
            String SQL = "SELECT * FROM Person";
            ResultSet resultSet = statement.executeQuery(SQL);
             while (resultSet.next()) {
                Person person = new Person();
                person.setId(resultSet.getInt("id"));
                person.setName(resultSet.getString("name"));
                person.setEmail(resultSet.getString("email"));
                person.setAge(resultSet.getInt("age"));
                people.add(person);
            }
          } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
         return people;
    }
    //создадим еще один класс PersonMapper это будет вторым аргументом
    //мы вынесли этот код по извлечению данных с таблицы и перевода его в объекты нашего класса Person и мы его вынесли
    //в отдельный класс. Это делается для того чтобы избавиться от дублировнаия кода

(5) Переделаем метод show
public Person show(int id) {
       return jdbcTemplate.query("SELECT * FROM Person WHERE id=?",new Object[]{id}, new PersonMapper())
               .stream().findAny().orElse(null);
//используем лямбду:.stream().findAny() - ищет объект в списке если объект есть то он возвращает.orElse(null);
(6) но мы можем не создавать свой собственный RowMapper тк есть готовый BeanPropertyRowMapper<>()











